\documentclass{beamer}

\usepackage{fancyvrb,tikz, dsfont}

\usetikzlibrary{automata,arrows}

\usetheme{Dresden}

\mode<presentation>

\title[Tolkienizer]{Tolkienizer}
%\subtitle{}
%\author[]{}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
   \frametitle{Contents}
   \tableofcontents[pausesections]
\end{frame}

\section{Introduction}

\begin{frame}
   \frametitle{What is Natural Language Processing?}
   \begin{itemize}
      \item Study of human language using computers
      \item Often uses statistical machine learning techniques
      \item Subfields include:
      \begin{itemize}
         \item Morphology
         \item Parsing
         \item Natural Language Understanding
      \end{itemize}
   \end{itemize}
\end{frame}

\begin{frame}
   \frametitle{Generating words with Tolkienizer}
   \begin{itemize}
      \item Task: generate ``real sounding'' words for a language
      \item Similar to morphology - identifying key sounds instead of roots
      \item Example: create new ``Elvish sounding'' words from samples of Tolkien's Elvish
      \item Implementation: Hidden Markov Models
   \end{itemize}
\end{frame}

\section{Who is this Markov, and why does he Hide his Models}

\subsection{Markov Processes}

\begin{frame}
   \frametitle{What is a Markov Process}
   \begin{enumerate}
   \item[] \small{\textbf{Markov Process:} A \textcolor{red}{stochastic} process with
   the \textcolor{red}{Markov property}.}
   \pause
   \item[] \textbf{Stochastic Process:} A random process parametrized by time.
   \pause
   \item[] \textbf{Markov Property:} Memoryless!
   \pause
   \end{enumerate}
   \begin{columns}[c]
   \column{1.5in}
   \begin{tikzpicture} [scale=0.5,->,>=stealth',shorten >=1pt,%
   auto,node distance=2cm,semithick,transform shape]

   \node[state,initial]  (q0)               {$q_{start}$};
   \node[state]          (q1) [below of=q0] {$q_1$};
   \node[state]          (q2) [below of=q1] {$q_2$};
   \node[state]          (q3) [below of=q2] {$q_3$};
   \node[state]          (q4) [below of=q3] {$q_{end}$};

   \path[->]    (q0) edge               node {}      (q1)
                (q1) edge               node {}      (q2)
                (q2) edge               node {}      (q3)
                (q3) edge               node {}      (q4);
   \end{tikzpicture}
   \column{1.5in}
   \begin{tikzpicture} [scale=0.5,->,>=stealth',shorten >=1pt,%
   auto,node distance=2cm,semithick,transform shape]

   \node[state,initial]  (q0)                        {$q_{start}$};
   \node[state]          (q1) [below left of=q0]     {$q_1$};
   \node[state]          (q2) [below of=q0]          {$q_2$};
   \node[state]          (q3) [below right of=q0]    {$q_3$};
   \node[state]          (q4) [below of=q2]          {$q_{end}$};

   \path[->]    (q0) edge               node {}      (q1)
                (q1) edge               node {}      (q2)
                (q0) edge               node {}      (q3)
                (q2) edge               node {}      (q4);
   \end{tikzpicture}
$\mathds{P} = [q_{end}|q_2,q_1,q_{start}]$
\pause
$\mathds{P} = [q_{end}|q_2]$
\end{columns}
\end{frame}

\subsection{Hidden Markov Models}
\begin{frame}
   \frametitle{What are HMM's}
   \begin{enumerate}
   \pause
   \item[] \small{\textbf{Bayesian Networks:} Directed acyclic graphs that
   represent dependencies between variables in a probabilistic model.}
   \pause
   \item[] \small{\textbf{Hidden Markov Models (HMM's):} Operate under the
   assumption that the system to be modeled is a Markov Model with hidden
   states. However, some information about this model is revealed. The goal is
   to guess the model based on that information.}
   \end{enumerate}
\end{frame}

\subsection{How this Applies to our Project}
\begin{frame}
   \frametitle{Why did we need all this?}
   \begin{columns}[c]
      \column{1.5in}
      \column{1.5in}
   \end{columns}
\end{frame}

\section{Development Process}

\subsection{Program Design}
\begin{frame}
   \frametitle{Overall Design}
   \begin{itemize}
      \item Two step process
      \begin{enumerate}
         \item Learn from a large set of words from some language
         \item Produce words that ``seem'' like they are in the language
      \end{enumerate}
      \item In the first phase we construct our Markov Model
      \item In the second we simply let it run.
   \end{itemize}
\end{frame}

\begin{frame}
   \frametitle{Interpreting the Input}
   \begin{itemize}
      \item Lexical Analyzer
      \begin{itemize}
         \item responsible for breaking the input into \emph{tokens}
         \item very flexible, can break up at word or letter boundaries
      \end{itemize}
      \item All tokens are eventually turned into strings
      \item Rest of program designed to deal with strings
      \begin{itemize}
         \item Completely agnostic about the type of the tokens
         \item Any type can be converted to a string
      \end{itemize}
   \end{itemize}
\end{frame}

\begin{frame}
   \frametitle{Representing Markov Models}
   \begin{itemize}
      \item Each state is defined by a sequence of three tokens
      \item The state has a set of tokens, each with a probability of being the
      next token
      \item During the learning phase, watch the input and update probabilites
      according to training data
      \item During the generation phase, follow the Markov Model, emitting
      symbols based on the probabilities at each state
   \end{itemize}
\end{frame}

\subsection{Implementation}

\begin{frame}
   \frametitle{Programming in Go}
   \begin{itemize}
      \item Go offers lightweight threads | hundreds of thousands of concurrent
      processes with minimal overhead.
      \item Efficient communication between lightweight threads, allowing
      programs to be build like UNIX tools (pipe and filter).
      \item Nodes of markov model implemented as individual threads
   \end{itemize}
\end{frame}

\begin{frame}
   \frametitle{Advantages of this Design}
   \begin{itemize}
      \item A single function is easy to implement and maintain.
      \item Nodes know only about themselves, no need for ``glue'' to hold
      software components together.
   \end{itemize}
\end{frame}

\end{document}
